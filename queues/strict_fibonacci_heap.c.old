#include "strict_fibonacci_heap.h"

//==============================================================================
// STATIC DECLARATIONS
//==============================================================================

static int is_active( strict_fibonacci_node *node );
static int is_active_root( strict_fibonacci_node *node );
static int is_linkable( strict_fibonacci_node *node );

static void enqueue_node( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static void dequeue_node( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static void link( strict_fibonacci_heap *queue, strict_fibonacci_node *parent,
    strict_fibonacci_node *child );

static void make_passive( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static void make_active( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static void make_active_root( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static void move_to_right( strict_fibonacci_node *node );
static void increase_rank( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static void decrease_rank( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static void increase_loss( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static void decrease_loss( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );

static void post_decrease_key_reduction( strict_fibonacci_heap *queue );
static void post_delete_min_reduction( strict_fibonacci_heap *queue );
static void post_meld_reduction( strict_fibonacci_heap *queue );

static int reduce_active_roots( strict_fibonacci_heap *queue );
static int reduce_root_degree( strict_fibonacci_heap *queue );
static int reduce_loss( strict_fibonacci_heap *queue );

static void release_to_garbage_collector( strict_fibonacci_heap *queue,
    strict_fibonacci_heap *garbage_queue );
static void garbage_collection( strict_fibonacci_heap *queue );

static void fix_extract( strict_fibonacci_heap *queue, fix_node *head,
    fix_node *tail );
static void fix_insert( strict_fibonacci_heap *queue, fix_node *head,
    fix_node *succ );

static void move_rank( strict_fibonacci_heap *queue, rank_record *rank,
    int type, int direction );
#define demote_rank(q,r,t) ( move_rank( q, r, t, STRICT_FIX_DEMOTE ) )
#define promote_rank(q,r,t) ( move_rank( q, r, t, STRICT_FIX_PROMOTE ) )
static void check_rank( strict_fibonacci_heap *queue, rank_record *rank,
    int type );

static int active_root_transformable( fix_node *fix );
static int loss_transformable( fix_node *fix );

static fix_node* find_fix_root( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static fix_node* find_fix_loss( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static void release_active( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static void release_rank( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );
static void remove_from_fix_list( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node );

static void print_tree( strict_fibonacci_heap *queue );
static void print_tree_rec( strict_fibonacci_node *node, int depth );
static void print_fix_list( strict_fibonacci_heap *queue );

//==============================================================================
// PUBLIC METHODS
//==============================================================================

strict_fibonacci_heap* pq_create( mem_map *map )
{
    strict_fibonacci_heap *queue = (strict_fibonacci_heap*) calloc( 1,
        sizeof( strict_fibonacci_heap ) );
    queue->map = map;

    queue->active = pq_alloc_node( map, STRICT_TYPE_ACTIVE );
    queue->active->flag = 1;
    
    return queue;
}

void pq_destroy( strict_fibonacci_heap *queue ){
    pq_clear( queue );
    free( queue );
}

void pq_clear( strict_fibonacci_heap *queue )
{
    mm_clear( queue->map );
    queue->size = 0;
    
    queue->root = NULL;
    queue->non_linkable_child = NULL;
    queue->q_head = NULL;
    
    queue->active = NULL;
    queue->rank_list = NULL;
    queue->fix_list = NULL;
    queue->singles = NULL;
}

key_type pq_get_key( strict_fibonacci_heap *queue, strict_item *node )
{
    return node->key;
}

item_type* pq_get_item( strict_fibonacci_heap *queue, strict_item *node )
{
    return (item_type*) &(node->item);
}

uint32_t pq_get_size( strict_fibonacci_heap *queue )
{
    return queue->size;
}

strict_item* pq_insert( strict_fibonacci_heap *queue, item_type item, key_type key )
{
    strict_fibonacci_node* wrapper = pq_alloc_node( queue->map,
        STRICT_TYPE_FIB_NODE );
    strict_item* item_wrapper = pq_alloc_node( queue->map, STRICT_TYPE_ITEM );
    ITEM_ASSIGN( item_wrapper->item, item );
    item_wrapper->key = key;
    item_wrapper->node = wrapper;
    wrapper->item = item_wrapper;
    wrapper->right = wrapper;
    wrapper->left = wrapper;
    wrapper->q_next = wrapper;
    wrapper->q_prev = wrapper;

    strict_fibonacci_node *parent, *child;
    if( queue->root == NULL )
        queue->root = wrapper;
    else
    {
        if( item_wrapper->key < queue->root->item->key )
        {
            parent = wrapper;
            child = queue->root;
        }
        else
        {
            parent = queue->root;
            child = wrapper;
        }

        link( queue, parent, child );
        queue->root = parent;
        enqueue_node( queue, child );

        //print_tree( queue );
        post_meld_reduction( queue );
    }
    
    queue->size++;
    garbage_collection( queue );

    print_tree( queue );

    return item_wrapper;
}

strict_fibonacci_node* pq_find_min( strict_fibonacci_heap *queue )
{
    if ( pq_empty( queue ) )
        return NULL;
    return queue->root;
}

key_type pq_delete_min( strict_fibonacci_heap *queue )
{
    if( pq_empty( queue ) )
        return 0;

    key_type key = queue->root->item->key;
    strict_fibonacci_node *current, *new_root, *old_root, *next, *prev, *end;
    int i, j;

    old_root = queue->root;
    
    if( old_root->left_child == NULL )
    {
        //printf("No children.\n");
        old_root = queue->root;
        make_passive( queue, old_root );
        queue->root = NULL;
        queue->non_linkable_child = NULL;
    }
    else
    {
        //printf("Finding minimum child.\n");
        new_root = old_root->left_child;
        current = new_root->right;
        while( current != old_root->left_child )
        {
            if( current->item->key < new_root->item->key )
                new_root = current;
            current = current->right;
        }

        //printf("Making new root passive.\n");
        if( new_root->active != NULL && new_root->active->flag )
            make_passive( queue, new_root );

        //printf("Pulling new root out of list.\n");
        next = new_root->right;
        prev = new_root->left;
        if( old_root->left_child == new_root )
        {
            if( next == new_root )
                old_root->left_child = NULL;
            else
                old_root->left_child = next;
        }
        prev->right = next;
        next->left = prev;
        new_root->right = new_root;
        new_root->left = new_root;
        new_root->parent = NULL;
        
        //printf("Moving linkable passive children of the new root to the right.\n");
        if( new_root->left_child != NULL )
        {
            end = new_root->left_child->left;
            current = end->right;
            while( current != end )
            {
                next = current->right;
                if( is_linkable( current ) )
                    move_to_right( current );
                current = next;
            }

            //printf("Setting non-linkable child.\n");
            current = new_root->left_child->left;
            while( is_linkable( current ) && current != new_root->left_child )
                current = current->left;
            queue->non_linkable_child = current;
        }
        else
            queue->non_linkable_child = NULL;

        //printf("Dequeueing new root and setting root.\n");
        dequeue_node( queue, new_root );
        queue->root = new_root;
        
        //printf("Linking old root's children.\n");
        while( old_root->left_child != NULL )
            link( queue, new_root, old_root->left_child );

        //printf("Releasing old root.\n");
        make_passive( queue, old_root );

        //printf("Linking queued nodes.\n");
        for( i = 0; i < 2; i++ )
        {
            current = queue->q_head;
            queue->q_head = current->q_next;
            for( j = 0; j < 2; j++ )
            {
                if( current->left_child != NULL &&
                        !is_active( current->left_child->left ) )
                    link( queue, new_root, current->left_child->left );
            }
        } 
    }

    pq_free_node( queue->map, STRICT_TYPE_ITEM, old_root->item );
    pq_free_node( queue->map, STRICT_TYPE_FIB_NODE, old_root );
    
    //printf("Reduction time.\n");
    post_delete_min_reduction( queue );
    //printf("Garbage collection.\n");
    garbage_collection( queue );
    
    return key;
}

key_type pq_delete( strict_fibonacci_heap *queue, strict_item *node )
{
    key_type key = node->key;
    
    pq_decrease_key( queue, node, 0 );
    pq_delete_min( queue );

    return key;
}

void pq_decrease_key( strict_fibonacci_heap *queue, strict_item *node,
    key_type new_key )
{
    strict_item *tmp_item;
    strict_fibonacci_node *fib_node = node->node;
    strict_fibonacci_node *old_parent = fib_node->parent;
    
    fib_node->item->key = new_key;

    if( old_parent == NULL )
        return;

    if( fib_node->item->key <= queue->root->item->key )
    {
        tmp_item = fib_node->item;
        fib_node->item = queue->root->item;
        queue->root->item = tmp_item;
        fib_node->item->node = fib_node;
        queue->root->item->node = queue->root;
    }

    link( queue, queue->root, fib_node );
    if( is_active( fib_node ) )
    {
        if( is_active( old_parent ) )
        {
            decrease_rank( queue, old_parent );
            if( !is_active_root( old_parent ) )
                increase_loss( queue, old_parent );
            make_active_root( queue, fib_node );
        }
    }
        
    post_decrease_key_reduction( queue );
    garbage_collection( queue );
}

strict_fibonacci_heap* pq_meld( strict_fibonacci_heap *a,
    strict_fibonacci_heap *b )
{
    strict_fibonacci_heap *new_heap = pq_create( a->map );
    strict_fibonacci_heap *big, *small;

    strict_fibonacci_node *big_head, *big_tail, *small_head, *small_tail;
    strict_fibonacci_node *parent, *child;

    if( a->size < b->size )
    {
        big = b;
        small = a;
    }
    else
    {
        big = a;
        small = b;
    }

    new_heap->size = big->size + small->size;
    new_heap->q_head = big->q_head;
    new_heap->active = big->active;
    new_heap->rank_list = big->rank_list;
    new_heap->fix_list = big->fix_list;
    new_heap->singles = big->singles;

    if( small->active != NULL )
        small->active->flag = 0;

    if( big->root->item->key < small->root->item->key )
    {
        parent = big->root;
        child = small->root;
        new_heap->root = big->root;
        new_heap->non_linkable_child = big->non_linkable_child;
    }
    else
    {
        parent = small->root;
        child = big->root;
        new_heap->root = small->root;
        new_heap->non_linkable_child = small->non_linkable_child;
    }

    link( new_heap, parent, child );
    enqueue_node( new_heap, child );

    big_head = big->q_head;
    big_tail = big_head->q_prev;
    small_head = small->q_head;
    small_tail = small_head->q_prev;

    big_head->q_prev = small_tail;
    small_tail->q_next = big_head;
    small_head->q_prev = big_tail;
    big_tail->q_next = small_head;

    release_to_garbage_collector( new_heap, small );
    free( small );
    free( big );

    garbage_collection( new_heap );

    return new_heap;
}

bool pq_empty( strict_fibonacci_heap *queue )
{
    return ( queue->size == 0 );
}

//==============================================================================
// STATIC METHODS
//==============================================================================

static int is_active( strict_fibonacci_node *node )
{
    return( node->active != NULL && node->active->flag );
}

static int is_active_root( strict_fibonacci_node *node )
{
    return( is_active( node ) && !is_active( node->parent ) );
}

static int is_linkable( strict_fibonacci_node *node )
{
    return( !is_active( node ) && ( node->left_child == NULL ||
        !is_active( node->left_child ) ) );
}

static void enqueue_node( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    if( queue->q_head == NULL )
    {
        queue->q_head = node;
        return;
    }

    strict_fibonacci_node *head = queue->q_head;
    strict_fibonacci_node *tail = head->q_prev;

    tail->q_next = node;
    node->q_prev = tail;

    head->q_prev = node;
    node->q_next = head;    
}

static void dequeue_node( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    node->q_next->q_prev = node->q_prev;
    node->q_prev->q_next = node->q_next;

    if( queue->q_head == node )
    {
        if( queue->q_head == node )
            queue->q_head = NULL;
        else
            queue->q_head = node->q_next;
    }

    node->q_next = node;
    node->q_prev = node;
}

static void link( strict_fibonacci_heap *queue, strict_fibonacci_node *parent,
    strict_fibonacci_node *child )
{
    strict_fibonacci_node *next = child->right;
    strict_fibonacci_node *prev = child->left;

    //printf("(%d,%d)\n",parent->item->item,child->item->item);

    prev->right = next;
    next->left = prev;
    child->right = child;
    child->left = child;

    if( child->parent != NULL && child->parent->left_child == child )
    {
        if( next == child )
            child->parent->left_child = NULL;
        else
            child->parent->left_child = next;
    }

    child->parent = parent;
    if( parent->left_child == NULL )
    {
        parent->left_child = child;
        if( parent == queue->root && !is_linkable( child ) )
            queue->non_linkable_child = child;
        if( is_active( child ) )
        {
            if( !is_active( parent ) )
                make_active_root( queue, child );
            else if( is_active_root( child ) )
                make_active( queue, child );
        }
    }
    else
    {
        if( parent != queue->root || is_active( child ) ||
            is_linkable( child ) )
        {
            next = parent->left_child;
            prev = next->left;
        }
        else
        {
            if( queue->non_linkable_child == NULL )
            {
                next = parent->left_child;
                prev = next->left;
                queue->non_linkable_child = child;
                parent->left_child = child;
            }
            else if( is_active( queue->non_linkable_child ) )
            {
                prev = queue->non_linkable_child;
                next = prev->right;
                queue->non_linkable_child = child;
            }
            else
            {
                next = queue->non_linkable_child;
                prev = next->left;
            }
        }

        child->left = prev;
        child->right = next;
        next->left = child;
        prev->right = child;

        if( is_active( child ) )
            parent->left_child = child;
    }
}

static void make_passive( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    if( node->active != NULL )
        release_active( queue, node );

    if( node->rank != NULL )
    {
        remove_from_fix_list( queue, node );
        release_rank( queue, node );
    }

    node->loss = 0;

    strict_fibonacci_node *end, *current;
    end = node->left_child;
    if( end != NULL )
    {
        if( is_active( end ) )
            make_active_root( queue, end );
        current = end->right;
        while( current != end )
        {
            if( is_active( current ) )
                make_active_root( queue, current );
            current = current->right;
        }
    }
}

static void make_active( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    print_fix_list( queue );
    if( node->active == NULL || !node->active->flag )
    {
        if( queue->non_linkable_child == node )
            queue->non_linkable_child = node->left;
        move_to_right( node );
        node->parent->left_child = node;
    }
    if( node->active != NULL && !node->active->flag )
        release_active( queue, node );
    print_fix_list( queue );
    node->active = queue->active;
    print_fix_list( queue );

    rank_record *new_rank, *old_rank;
    if( node->rank == NULL )
    {
        node->rank = queue->rank_list;
        if( node->rank == NULL || node->rank->rank != 0 )
        {
            new_rank = pq_alloc_node( queue->map, STRICT_TYPE_RANK );
            old_rank = queue->rank_list;
            if( old_rank == NULL )
            {
                new_rank->inc = new_rank;
                new_rank->dec = new_rank;
            }
            else
            {
                new_rank->dec = old_rank->dec;
                new_rank->inc = old_rank;
                new_rank->dec->inc = new_rank;
                old_rank->dec = new_rank;
            }

            queue->rank_list = new_rank;
            node->rank = new_rank;
        }
    }

    remove_from_fix_list( queue, node );
    node->loss = 0;
}

static void make_active_root( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    //printf("Making %d an active root\n",node->item->item);
    print_fix_list( queue );
    //printf(" -> making active if not already\n");
    if( node->active == NULL || !node->active->flag )
        make_active( queue, node );
    //printf(" -> node is active\n");
    print_fix_list( queue );

    fix_node *fix = pq_alloc_node( queue->map, STRICT_TYPE_FIX_NODE );
    fix->node = node;
    fix->rank = node->rank;
    fix->left = fix;
    fix->right = fix;

    fix_node *succ;
    if( fix->rank->active_roots == NULL )
        succ = queue->singles;
    else
        succ = fix->rank->active_roots;
    fix->rank->active_roots = fix;
    fix_insert( queue, fix, succ );
    if( queue->fix_list == succ )
        queue->fix_list = fix;

    check_rank( queue, fix->rank, STRICT_FIX_ROOT );
    print_fix_list( queue );
    find_fix_root( queue, node );

    //printf("Make active children non-roots.\n");
    strict_fibonacci_node *end, *current;
    end = node->left_child;
    if( end != NULL )
    {
        if( is_active( end ) )
            make_active( queue, end );
        current = end->right;
        while( current != end )
        {
            if( is_active( current ) )
                make_active( queue, current );
            current = current->right;
        }
    }
    //printf("Done with child root repair.\n");
}

static void move_to_right( strict_fibonacci_node *node )
{
    if( node->parent->left_child == node )
    {
        node->parent->left_child = node->right;
        return;
    }
    else if( node->parent->left_child->left == node )
        return;
        
    strict_fibonacci_node *next = node->right;
    strict_fibonacci_node *prev = node->left;

    prev->right = next;
    next->left = prev;

    next = node->parent->left_child;
    prev = next->left;

    next->left = node;
    prev->right = node;
    node->right = next;
    node->left = prev;
}

static void increase_rank( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    //printf("Increasing rank of %d.\n",node->item->item);
    print_fix_list( queue );
    rank_record *old_rank = node->rank;
    rank_record *new_rank = old_rank->inc;
    if( new_rank->rank != old_rank->rank + 1 )
    {
        new_rank = pq_alloc_node( queue->map, STRICT_TYPE_RANK );
        new_rank->rank = old_rank->rank + 1;
        new_rank->inc = old_rank->inc;
        new_rank->dec = old_rank;
        new_rank->inc->dec = new_rank;
        old_rank->inc = new_rank;
    }

    //printf("Finding old fix nodes.\n");
    fix_node *fix = find_fix_root( queue, node );
    if( fix == NULL )
        fix = find_fix_loss( queue, node );
    if( fix != NULL )
        fix_extract( queue, fix, fix );

    //printf("Releasing old rank.\n");
    release_rank( queue, node );
    node->rank = new_rank;

    fix_node *succ = NULL;
    int type;
    if( fix != NULL )
    {
        //printf("Setting new rank of fix node.\n");
        fix->rank = node->rank;
        
        if( is_active_root( node ) )
        {
            //printf(" -> active root!\n");
            type = STRICT_FIX_ROOT;
            succ = fix->rank->active_roots;
            //if( succ != NULL )
            //    printf("\t\t\t\tSucc: %d\n",succ->node->item->item);
            fix->rank->active_roots = fix;
        }
        else
        {
            //printf(" -> lossy node!\n");
            type = STRICT_FIX_LOSS;
            succ = fix->rank->loss;
            if( succ != NULL )
                succ = succ->right;
            fix->rank->loss = fix;
        }
        
        //printf("Inserting fix node.\n");
        print_fix_list( queue );
        fix_insert( queue, fix, succ );
        if( queue->fix_list == succ )
            queue->fix_list = fix;
        if( queue->singles == succ && !is_active_root( node ) )
            queue->singles = fix;
        print_fix_list( queue );
        //printf("Checking ranks.\n");
        check_rank( queue, new_rank, type );
        check_rank( queue, old_rank, type );
        //printf("Done increasing rank.\n");
    }
    //print_fix_list( queue );
}

static void decrease_rank( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    //printf("Decreasing rank of %d.\n",node->item->item);
    print_fix_list( queue );
    rank_record *old_rank = node->rank;
    rank_record *new_rank = old_rank->dec;
    if( new_rank->rank != old_rank->rank - 1 )
    {
        new_rank = pq_alloc_node( queue->map, STRICT_TYPE_RANK );
        new_rank->rank = old_rank->rank - 1;
        new_rank->dec = old_rank->dec;
        new_rank->inc = old_rank;
        new_rank->dec->inc = new_rank;
        old_rank->dec = new_rank;
    }

    //printf("Finding old fix nodes.\n");
    fix_node *fix = find_fix_root( queue, node );
    if( fix == NULL )
        fix = find_fix_loss( queue, node );
    if( fix != NULL )
        fix_extract( queue, fix, fix );

    //printf("Releasing old rank.\n");
    release_rank( queue, node );
    node->rank = new_rank;

    fix_node *succ = NULL;
    int type;
    if( fix != NULL )
    {
        //printf("Setting new rank of fix node.\n");
        fix->rank = node->rank;
        
        if( is_active_root( node ) )
        {
            //printf(" -> active root!\n");
            type = STRICT_FIX_ROOT;
            succ = fix->rank->active_roots;
            //if( succ != NULL )
                //printf("\t\t\t\tSucc: %d\n",succ->node->item->item);
            fix->rank->active_roots = fix;
        }
        else
        {
            //printf(" -> lossy node!\n");
            type = STRICT_FIX_LOSS;
            succ = fix->rank->loss;
            if( succ != NULL )
                succ = succ->right;
            fix->rank->loss = fix;
        }
        
        //printf("Inserting fix node.\n");
        print_fix_list( queue );
        fix_insert( queue, fix, succ );
        if( queue->fix_list == succ )
            queue->fix_list = fix;
        if( queue->singles == succ && !is_active_root( node ) )
            queue->singles = fix;
        print_fix_list( queue );
        //printf("Checking ranks.\n");
        check_rank( queue, new_rank, type );
        check_rank( queue, old_rank, type );
        //printf("Done decreasing rank.\n");
    }
    print_fix_list( queue );
}

static void increase_loss( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    //printf("Increasing loss of node %d\n",node->item->item);
    fix_node *pred, *succ;
    fix_node *fix = find_fix_loss( queue, node );
    if( fix == NULL )
    {
        fix = pq_alloc_node( queue->map, STRICT_TYPE_FIX_NODE );
        fix->node = node;
        fix->rank = node->rank;

        pred = fix->rank->loss;
        if( pred == NULL )
        {
            fix->right = fix;
            fix->left = fix;

            fix_insert( queue, fix, queue->singles );
        }
        else
        {
            succ = pred->right;
            
            fix->left = pred;
            fix->right = succ;
            succ->left = fix;
            pred->right = fix;
        }
        fix->rank->loss = fix;
    }

    node->loss++;
    check_rank( queue, fix->rank, STRICT_FIX_LOSS );
}

static void decrease_loss( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    //printf("Decreasing loss of node %d\n",node->item->item);
    fix_node *fix = find_fix_loss( queue, node );
    fix_extract( queue, fix, fix );

    check_rank( queue, fix->rank, STRICT_FIX_LOSS );
    
    pq_free_node( queue->map, STRICT_TYPE_FIX_NODE, fix );
    node->loss = 0;
}

static void post_decrease_key_reduction( strict_fibonacci_heap *queue )
{
    uint32_t count_active_roots = 0;
    uint32_t count_root_degree = 0;

    reduce_loss( queue );

    while( count_active_roots < 6 || count_root_degree < 4 )
    {
        if( count_active_roots < 1 && reduce_active_roots( queue ) )
            count_active_roots++;
        else if( count_root_degree < 1 && reduce_root_degree( queue ) )
            count_root_degree++;
        else
            break;
    }
}

static void post_delete_min_reduction( strict_fibonacci_heap *queue )
{
    reduce_loss( queue );
    
    while( 1 )
    {
        if( reduce_active_roots( queue ) )
            continue;
        else if( reduce_root_degree( queue ) )
            continue;
        else
            break;
    }
}

static void post_meld_reduction( strict_fibonacci_heap *queue )
{
    uint32_t count_active_roots = 0;
    uint32_t count_root_degree = 0;

    while( count_active_roots < 1 || count_root_degree < 1 )
    {
        if( count_active_roots < 1 && reduce_active_roots( queue ) )
            count_active_roots++;
        else if( count_root_degree < 1 && reduce_root_degree( queue ) )
            count_root_degree++;
        else
            break;
    }
}

static int reduce_active_roots( strict_fibonacci_heap *queue )
{
    if( !active_root_transformable( queue->fix_list ) )
        return 0; // transformable section of active root list is empty
    
    fix_node *parent, *child;

    //printf("Performing active root reduction.\n");
    if( queue->fix_list->node->item->key <
            queue->fix_list->right->node->item->key )
    {
        parent = queue->fix_list;
        child = queue->fix_list->right;
    }
    else
    {
        parent = queue->fix_list->right;
        child = queue->fix_list;
    }

    link( queue, parent->node, child->node );
    make_active( queue, child->node );
    increase_rank( queue, parent->node );

    check_rank( queue, queue->fix_list->rank, STRICT_FIX_ROOT );
    
    return 1;
}

static int reduce_root_degree( strict_fibonacci_heap *queue )
{
    strict_fibonacci_node *a = queue->root->left_child->left;
    strict_fibonacci_node *b = a->left;
    strict_fibonacci_node *c = b->left;
    strict_fibonacci_node *grand, *parent, *child;
    if( a == queue->non_linkable_child || b == a ||
            b == queue->non_linkable_child || c == a ||
            c == queue->non_linkable_child )
        return 0; // not enough linkable passive nodes

    //print_tree( queue );
    //printf("Performing root degree reduction on %d, %d, and %d.\n",a->item->item,b->item->item,c->item->item);
    if( a->item->key < b->item->key )
    {
        if( b->item->key < c->item->key )
        {
            grand = a;
            parent = b;
            child = c;
        }
        else if( a->item->key < c->item->key )
        {
            grand = a;
            parent = c;
            child = b;
        }
        else
        {
            grand = c;
            parent = a;
            child = b;
        }
    }
    else
    {
        if( a->item->key < c->item->key )
        {
            grand = b;
            parent = a;
            child = c;
        }
        else if( b->item->key < c->item->key )
        {
            grand = b;
            parent = c;
            child = a;
        }
        else
        {
            grand = c;
            parent = b;
            child = a;
        }

    }

    link( queue, parent, child );
    make_active( queue, parent );
    
    link( queue, grand, parent );
    make_active_root( queue, grand );
    queue->root->left_child = grand;
    increase_rank( queue, grand );
    
    return 1;
}

static int reduce_loss( strict_fibonacci_heap *queue )
{
    if( queue->fix_list == NULL )
        return 0; // no active nodes

    fix_node *end = queue->fix_list->left;
    fix_node *next = end->left;
    int transform = loss_transformable( queue->fix_list );
    if( !transform )
        return 0; // no loss-transformable nodes

    fix_node *single;
    strict_fibonacci_node *old_parent, *parent, *child;
    
    //printf("Performing loss reduction.\n");
    if( transform == 2 )
    {
        if( end->node->loss > 1 )
            single = end;
        else
            single = next;
        
        parent = single->node->parent;
        link( queue, queue->root, single->node );
        decrease_loss( queue, single->node );
        decrease_rank( queue, parent );
        if( !is_active_root( parent ) )
            increase_loss( queue, parent );
        make_active_root( queue, single->node );

        check_rank( queue, queue->fix_list->left->rank, STRICT_FIX_LOSS );
    }
    else
    {
        if( end->node->item->key < next->node->item->key )
        {
            parent = end->node;
            child = next->node;
        }
        else
        {
            parent = next->node;
            child = end->node;
        }

        old_parent = child->parent;
        link( queue, parent, child );
        increase_rank( queue, parent );
        decrease_loss( queue, parent );
        decrease_loss( queue, child );

        if( old_parent != parent )
        {
            decrease_rank( queue, old_parent );
            if( !is_active_root( old_parent ) )
                increase_loss( queue, old_parent );
        }
    }
    
    return 1;
}

static void release_to_garbage_collector( strict_fibonacci_heap *queue,
    strict_fibonacci_heap *garbage_queue )
{
    rank_record *next_rank, *prev_rank, *garbage_next_rank, *garbage_prev_rank;
    fix_node *next_fix, *prev_fix, *garbage_next_fix, *garbage_prev_fix;
    
    if( garbage_queue->garbage_fix != NULL )
    {
        next_fix = queue->garbage_fix;
        prev_fix = next_fix->left;
        garbage_next_fix = garbage_queue->garbage_fix;
        garbage_prev_fix = garbage_next_fix->left;

        garbage_next_fix->left = prev_fix;
        prev_fix->right = garbage_next_fix;
        garbage_prev_fix->right = next_fix;
        next_fix->left = garbage_prev_fix;        
    }
    if( garbage_queue->garbage_rank != NULL )
    {
        next_rank = queue->garbage_rank;
        prev_rank = next_rank->dec;
        garbage_next_rank = garbage_queue->garbage_rank;
        garbage_prev_rank = garbage_next_rank->dec;

        garbage_next_rank->dec = prev_rank;
        prev_rank->inc = garbage_next_rank;
        garbage_prev_rank->inc = next_rank;
        next_rank->dec = garbage_prev_rank;
    }
    if( garbage_queue->fix_list != NULL )
    {
        next_fix = queue->garbage_fix;
        prev_fix = next_fix->left;
        garbage_next_fix = garbage_queue->fix_list;
        garbage_prev_fix = garbage_next_fix->left;

        garbage_next_fix->left = prev_fix;
        prev_fix->right = garbage_next_fix;
        garbage_prev_fix->right = next_fix;
        next_fix->left = garbage_prev_fix;
    }
    if( garbage_queue->rank_list != NULL )
    {
        next_rank = queue->garbage_rank;
        prev_rank = next_rank->dec;
        garbage_next_rank = garbage_queue->rank_list;
        garbage_prev_rank = garbage_next_rank->dec;

        garbage_next_rank->dec = prev_rank;
        prev_rank->inc = garbage_next_rank;
        garbage_prev_rank->inc = next_rank;
        next_rank->dec = garbage_prev_rank;
    }
}

static void garbage_collection( strict_fibonacci_heap *queue )
{
    rank_record *tmp_rank;
    fix_node *tmp_fix;

    if( queue->garbage_fix != NULL )
    {
        tmp_fix = queue->garbage_fix;
        tmp_fix->left->right = tmp_fix->right;
        tmp_fix->right->left = tmp_fix->left;
        queue->garbage_fix = tmp_fix->right;
        if( queue->garbage_fix == tmp_fix )
            queue->garbage_fix = NULL;
        pq_free_node( queue->map, STRICT_TYPE_FIX_NODE, tmp_fix );
    }

    if( queue->garbage_rank != NULL )
    {
        tmp_rank = queue->garbage_rank;
        tmp_rank->inc->dec = tmp_rank->inc;
        tmp_rank->dec->inc = tmp_rank->dec;
        queue->garbage_rank = tmp_rank->inc;
        if( queue->garbage_rank == tmp_rank )
            queue->garbage_rank = NULL;
        pq_free_node( queue->map, STRICT_TYPE_RANK, tmp_rank );
    }
}

static void fix_extract( strict_fibonacci_heap *queue, fix_node *head,
    fix_node *tail )
{
    tail->right->left = head->left;
    head->left->right = tail->right;

    if( queue->fix_list == head )
    {
        if( tail->right == head )
            queue->fix_list = NULL;
        else
            queue->fix_list = tail->right;
    }
    if( queue->singles == head )
    {
        if( tail->right == head || is_active_root( tail->right->node ) )
            queue->singles = NULL;
        else
            queue->singles = tail->right;
    }

    if( head == head->rank->active_roots )
    {
        if( tail->right->rank == head->rank && tail->right->node != head->node )
            head->rank->active_roots = tail->right;
        else
            head->rank->active_roots = NULL;
    }

    if( tail == tail->rank->loss )
    {
        if( head->left->rank == tail->rank && head->left->node != tail->node )
            tail->rank->loss = head->left;
        else
            tail->rank->loss = NULL;
    }

    tail->right = head;
    head->left = tail;
}

static void fix_insert( strict_fibonacci_heap *queue, fix_node *head,
    fix_node *succ )
{
    fix_node *tail = head->left;
    
    if( queue->fix_list == NULL )
        queue->fix_list = head;
    else
    {
        if( succ == NULL )
            succ = queue->fix_list;

        tail->right = succ;
        head->left = succ->left;
        succ->left = tail;
        head->left->right = head;
    }
}

static void move_rank( strict_fibonacci_heap *queue, rank_record *rank,
    int type, int direction )
{
    //printf("Moving rank.\n");
    print_fix_list( queue );
    fix_node *head, *tail, *succ;
    if( type == STRICT_FIX_ROOT )
    {
        if( rank->active_roots == NULL )
            return;
            
        head = rank->active_roots;
        tail = head;
        if( tail->right->rank == rank &&
            is_active_root( tail->right->node ) )
        {
            tail = tail->right;
            while( tail != head && tail->right->rank == rank &&
                    is_active_root( tail->right->node ) )
                tail = tail->right;
        }
    }
    else
    {
        if( rank->loss == NULL )
            return;
            
        tail = rank->loss;
        head = tail;
        if( head->left->rank == rank && !is_active_root( head->left->node ) )
        {
            head = head->left;
            while( head != tail && head->left->rank == rank &&
                    !is_active_root( head->left->node ) )
                head = head->left;
        }
    }

    if( direction == STRICT_FIX_DEMOTE )
        succ = queue->singles;
    else
        succ = queue->fix_list;

    fix_extract( queue, head, tail );
    fix_insert( queue, head, succ );

    if( direction == STRICT_FIX_DEMOTE && type == STRICT_FIX_LOSS )
        queue->singles = head;
    else if( direction == STRICT_FIX_PROMOTE && type == STRICT_FIX_ROOT )
        queue->fix_list = head;
    
    if( type == STRICT_FIX_ROOT )
        rank->active_roots = head;
    else
        rank->loss = tail;

    //if( direction == STRICT_FIX_PROMOTE )
    //    printf("Promoted rank %d\n",rank->rank);
    //else
    //    printf("Demoted rank %d\n",rank->rank);
    //print_fix_list( queue );
}

static void check_rank( strict_fibonacci_heap *queue, rank_record *rank,
    int type )
{
    if( type == STRICT_FIX_ROOT )
    {
        //printf("Checking fix root rank.\n");
        if( rank->active_roots == NULL )
            return;

        if( active_root_transformable( rank->active_roots ) )
            promote_rank( queue, rank, type );
        else
            demote_rank( queue, rank, type );
    }
    else
    {
        if( rank->loss == NULL )
            return;

        if( loss_transformable( rank->loss->right ) )
            promote_rank( queue, rank, type );
        else
            demote_rank( queue, rank, type );
    }
}

static int active_root_transformable( fix_node *fix )
{
    //printf("Checking active root transformable.\n");
    if( fix == NULL )
        return 0;

    if( fix->right == fix )
        return 0;

    if( !is_active_root( fix->node ) )
        return 0;

    if( !is_active_root( fix->right->node ) )
        return 0;

    if( fix->rank != fix->right->rank )
        return 0;
        
    return 1;
}

static int loss_transformable( fix_node *fix )
{
    //printf("Checking loss transformable.\n");
    if( fix == NULL )
        return 0;

    if( is_active_root( fix->left->node ) )
        return 0;

    if( fix->left->node->loss > 1 )
        return 2;

    if( is_active_root( fix->left->left->node ) )
        return 0;

    if( fix->left->rank != fix->left->left->rank )
        return 0;

    if( fix->left->left->node->loss > 1 )
        return 2;

    return 1;
}

static fix_node* find_fix_root( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    //printf("\t\tSearching active roots for %d...\n",node->item->item);
    if( node->rank == NULL || node->rank->active_roots == NULL )
        return NULL;
    //printf("\t\t\t...of rank %d.\n",node->rank->rank);

    fix_node *fix = node->rank->active_roots;
    //printf("\t\t\t%d,",fix->node->item->item);
    if( fix->rank == node->rank && fix->node != node &&
        fix != node->rank->active_roots )
    {
        fix = fix->right;
        //printf("%d,",fix->node->item->item);
        while( fix->rank == node->rank && fix->node != node &&
            fix != node->rank->active_roots )
        {
            fix = fix->right;
            //printf("%d,",fix->node->item->item);
        }
    }
    //printf("\n");
        
    if( fix->node == node )
        return fix;
    else
        return NULL;
}

static fix_node* find_fix_loss( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    if( node->rank == NULL || node->rank->loss == NULL )
        return NULL;
        
    fix_node *fix = node->rank->loss;
    while( fix->rank == node->rank && fix->node != node )
        fix = fix->left;

    if( fix->node == node )
        return fix;
    else
        return NULL;
}

static void release_active( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    node->active->ref_count--;
    if( node->active->ref_count == 0 )
    {
        if( queue->active == node->active )
            queue->active = NULL;
        pq_free_node( queue->map, STRICT_TYPE_ACTIVE, node->active );
    }
    node->active = NULL;
}

static void release_rank( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    node->rank->ref_count--;
    if( node->rank->ref_count == 0 )
    {
        //printf("Freeing rank %d.\n",node->rank->rank);
        node->rank->inc->dec = node->rank->dec;
        node->rank->dec->inc = node->rank->inc;
        if( queue->rank_list == node->rank )
        {
            if( node->rank->inc == node->rank )
                queue->rank_list = NULL;
            else
                queue->rank_list = node->rank->inc;
        }
        pq_free_node( queue->map, STRICT_TYPE_RANK, node->rank );
    }
    else
    {
        //printf("Not freeing rank %d.\n",node->rank->rank);
        if( node->rank->active_roots != NULL &&
            node->rank->active_roots->node == node )
        {
            //printf("Fixing active rank.\n");
            if( node->rank->active_roots->right->rank == node->rank &&
                    node->rank->active_roots->right->node != node )
                node->rank->active_roots = node->rank->active_roots->right;
            else
                node->rank->active_roots = NULL;
        }
        else if( node->rank->loss != NULL && node->rank->loss->node == node )
        {
            if( node->rank->loss->left->rank == node->rank &&
                    node->rank->loss->left->node != node )
                node->rank->loss = node->rank->loss->left;
            else
                node->rank->loss = NULL;
        }
    }
    node->rank = NULL;
}

static void remove_from_fix_list( strict_fibonacci_heap *queue,
    strict_fibonacci_node *node )
{
    if( node->rank == NULL )
        return;

    fix_node *fix = find_fix_root( queue, node );
    if( fix != NULL )
    {
        fix_extract( queue, fix, fix );
        pq_free_node( queue->map, STRICT_TYPE_FIX_NODE, fix );
    }
    else
    {
        fix = find_fix_loss( queue, node );
        if( fix != NULL )
        {
            fix_extract( queue, fix, fix );
            pq_free_node( queue->map, STRICT_TYPE_FIX_NODE, fix );
        }
    }
}

static void print_tree( strict_fibonacci_heap *queue )
{
    print_fix_list( queue );
    printf("\tTree: ");
    print_tree_rec( queue->root, 1 );
    printf("\n");
}

static void print_tree_rec( strict_fibonacci_node *node, int depth )
{
    if( node == NULL )
        return;

    int i;
    strict_fibonacci_node *current;
    printf("\n");
    for( i = 0; i < depth; i++ )
        printf("\t");
    printf("%d",node->item->item);
    print_tree_rec( node->left_child, depth + 1 );
    if( node->left_child != NULL )
    {
        current = node->left_child->right;
        while( current != node->left_child )
        {
            print_tree_rec( current, depth + 1 );
            current = current->right;
        }
    }
    //printf("");
}

static void print_fix_list( strict_fibonacci_heap *queue )
{
    return;
    printf("\tFix: {");
    fix_node *current = queue->fix_list;
    if( current != NULL )
    {
        if( is_active_root( current->node ) )
        {
            if( current == current->rank->active_roots )
                printf("%d(R%d*),",current->node->item->item,current->rank->rank);
            else
                printf("%d(R%d),",current->node->item->item,current->rank->rank);
        }
        else
        {
            if( current == current->rank->loss )
                printf("%d(L%d*),",current->node->item->item,current->rank->rank);
            else
                printf("%d(L%d),",current->node->item->item,current->rank->rank);
        }
        current = current->right;
        while( current != queue->fix_list )
        {
            if( is_active_root( current->node ) )
            {
                if( current == current->rank->active_roots )
                    printf("%d(R%d*),",current->node->item->item,current->rank->rank);
                else
                    printf("%d(R%d),",current->node->item->item,current->rank->rank);
            }
            else
            {
                if( current == current->rank->loss )
                    printf("%d(L%d*),",current->node->item->item,current->rank->rank);
                else
                    printf("%d(L%d),",current->node->item->item,current->rank->rank);
            }
            current = current->right;
        }
    }
    printf("}\n");
}
